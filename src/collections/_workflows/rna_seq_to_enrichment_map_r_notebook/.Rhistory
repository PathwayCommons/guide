}
if(dim(meta)[1] != length(filelist)) stop('Mismatch in files declared in metadata')
for(file in filelist){
if(!file.exists(file)) stop('invalid file/directory')
fname <- basename(file)
findex <- which(meta$id == fname)
if(length(findex) == 0) stop(paste0('Could not find match in metadata for ', fname))
class_order <- append(class_order, which(meta$id == fname))
input_df <- read.table(file,
check.names = FALSE,
stringsAsFactors = FALSE,
row.names = 1,
sep = "\t",
header = FALSE)
colnames(input_df) <- tools::file_path_sans_ext(fname)
if (i == 0){
data_df <- input_df
i = i + 1
next()
}
data_df <- merge(data_df,
input_df,
by = "row.names",
all = FALSE)
rownames(data_df) <- data_df$Row.names
data_df <- subset(data_df, select = -Row.names)
i = i + 1
}
gene_model <- get_gene_model( data_df, species, source_name, target_name )
if(is.null(gene_model)) stop( 'Could not reliably map input gene ids' )
# Sync up data rows (name, order) with gene_model returned
data_df_mapped <- map_names(data_df, gene_model, source_name)
# Create the SummarizedExperiment
colData <- data.frame(class=meta[class_order,]$class, row.names=colnames(data_df_mapped))
data_se <- SummarizedExperiment::SummarizedExperiment(
assays = list(counts = data.matrix(data_df_mapped)),
rowRanges = gene_model,
colData=colData)
return(data_se)
}
#' Create a data frame housing the RNA-seq metadata
#'
#' This function requires a tab-delimited text file with headers for
#' the sample read 'id' and 'class'. Each row entry is a corresponding filename
#' and class assignment. Only accepts pair-wise comparison so there must be
#' exactly 2 classes.
#'
#' @param metadata_file a path to a tab-delimited metadata file
#' @return A data frame
#'
#' @export
create_meta <- function(metadata_file) {
if(!file.exists(metadata_file)) stop('file does not exist')
if(!grepl(".txt$", metadata_file)){
stop("Uploaded file must be a tab-delimited .txt file!")
}
meta <- read.table(metadata_file,
check.names = FALSE,
colClasses = c("character", "factor"),
sep = "\t", header=TRUE)
if(!all.equal(colnames(meta), c("id", "class"))) stop('check column headers')
return(meta)
}
#' Normalize the data.frame nameswith those on a \code{\link[GenomicRanges]{GRanges}} object
#'
#' !!!!!!!!!!!!Alert alert alert ---- mapping between namespaces is not bijective.!!!!!!!!!!!!!
#'
#' Assumes that the gene_model has a meta-data column with source_name
#'
#' @param data_df the data frame to synchronize
#' @param gene_model the \code{\link[GenomicRanges]{GRanges}} object to match rows with
#'
#' @return A \code{\link[base]{data.frame}} with the same rows and names as the input \code{\link[GenomicRanges]{GRanges}}
#'
#' @export
map_names <- function(data_df, gene_model, source_name){
# Filter data_df for source_name
indices_data_df_source <- rownames( data_df ) %in% GenomicRanges::mcols( gene_model )[[source_name]]
subset_data_df_source <- data_df[ indices_data_df_source, ]
# Recreate the data frame
merged_data_df <- merge( subset_data_df_source,
data.frame( GenomicRanges::mcols( gene_model ), target_name = names(gene_model) ),
by.x = "row.names", by.y = source_name)
# merged data could still have duplicates!
# indices_merged_data_df_unique <- !duplicated(merged_data_df[[ "Row.names" ]])
# merged_data_df_unique <- merged_data_df[indices_merged_data_df_unique,]
# Set row names to target_name
row.names( merged_data_df ) <- merged_data_df$target_name
# Drop name columns
merged_data_df <- merged_data_df[, -which(names(merged_data_df) %in% c("Row.names", "target_name")) ]
# Reorder the rows to match
merged_data_df_reordered <- merged_data_df[ match(names(gene_model), rownames(merged_data_df)), ]
return(merged_data_df_reordered)
}
#' Retrieve the gene info
#'
#'  !!!!!!!!!!!!Alert alert alert ---- mapping between namespaces is not bijective.!!!!!!!!!!!!!
#'
#' @param data_df the data frame of genes (rownames) and samples (colnames)
#' @param species the species (mouse, human)
#' @param source_name attribute (gene namespace) input
#' @param target_name attribute (gene namespace) desired
#'
#' @return A \code{\link[GenomicRanges]{GRanges}} having unique and valid target_name entries
#'
#' @export
get_gene_model <- function( data_df, species, source_name, target_name ){
if(missing(species) ||
!grepl("mouse", species, ignore.case = TRUE) &&
!grepl("human", species, ignore.case = TRUE)) stop("Species must be human or mouse")
dataset = switch(species,
mouse = "mmusculus_gene_ensembl",
human = "hsapiens_gene_ensembl")
mart_used = biomaRt::useMart("ENSEMBL_MART_ENSEMBL")
ensembl = biomaRt::useDataset(dataset, mart = mart_used)
attributes_available <- biomaRt::listAttributes(ensembl)
if( !source_name %in% attributes_available$name ||
!target_name %in% attributes_available$name ) stop("Invalid source/target name")
bm_info <- biomaRt::getBM(attributes = c("chromosome_name",
"start_position", "end_position", "strand",
source_name, target_name),
filters = source_name,
values = rownames(data_df),
mart = ensembl)
rowRanges <- GenomicRanges::GRanges(seqnames = paste0("chr", bm_info$chromosome_name),
ranges = IRanges::IRanges(start = bm_info$start_position, end = bm_info$end_position),
strand = bm_info$strand)
meta <- data.frame(bm_info[[source_name]])
colnames(meta) <- c(source_name)
GenomicRanges::mcols(rowRanges) <- meta
names(rowRanges) <- bm_info[[target_name]]
# Filter gene_model for valid target_name
# GRanges objects act like vectors for subsetting
gene_model <- rowRanges[ (names(rowRanges) != "") ]
gene_model <- gene_model[ !duplicated(GenomicRanges::mcols(gene_model)[[source_name]]) ]
gene_model <- gene_model[ !duplicated(names(gene_model)) ]
return(gene_model)
}
source_name <- "ensembl_gene_id"
target_name <- "hgnc_symbol"
species <- "human"
brca_hd_tep_se <- merge_data(
tep_rnaseq_metadata,
species,
source_name,
target_name,
tep_rnaseq_filelist)
source_name <- "ensembl_gene_id"
target_name <- "hgnc_symbol"
species <- "human"
brca_hd_tep_se <- merge_data(
tep_rnaseq_metadata,
species,
source_name,
target_name,
tep_rnaseq_filelist)
source_name <- "ensembl_gene_id"
target_name <- "hgnc_symbol"
species <- "human"
brca_hd_tep_se <- merge_data(
tep_rnaseq_metadata,
species,
source_name,
target_name,
tep_rnaseq_filelist)
brca_hd_tep_se
knitr::kable(SummarizedExperiment::colData(brca_hd_tep_se))
brca_hd_tep_rowRanged_df <- as.data.frame(SummarizedExperiment::rowRanges(brca_hd_tep_se))
knitr::kable(head(brca_hd_tep_rowRanged_df))
dim(brca_hd_tep_rowRanged_df)
knitr::kable(head(SummarizedExperiment::assays(brca_hd_tep_se)[["counts"]])[, c(1,2,6,7)])
### Minimum number of mapped read counts per sample
min_counts <- 5
### Declare baseline (i.e. control) and test classes
baseline_class <- "HD"
test_class <- "BrCa"
comparison <- c(baseline_class, test_class)
brca_hd_tep_se_counts <- SummarizedExperiment::assays(brca_hd_tep_se)[["counts"]]
brca_hd_tep_se_group <- SummarizedExperiment::colData(brca_hd_tep_se)[["class"]]
### Find genes (rows) with a minimum number of counts
index_test_class <- brca_hd_tep_se_group == comparison[1]
index_baseline_class <- brca_hd_tep_se_group == comparison[2]
row_with_mincount <-
rowSums(edgeR::cpm(brca_hd_tep_se_counts) > min_counts) >=
min(sum(index_baseline_class), sum(index_test_class))
### Subset the original data accordingly
brca_hd_tep_dge_counts <- brca_hd_tep_se_counts[row_with_mincount,]
### Push the data into the edgeR::DGEList
brca_hd_tep_filtered_dge <-
edgeR::DGEList(counts = brca_hd_tep_dge_counts, group = brca_hd_tep_se_group)
knitr::kable(head(brca_hd_tep_filtered_dge[["counts"]])[, c(1,2,5,6)])
knitr::kable(brca_hd_tep_filtered_dge[["samples"]])
brca_hd_tep_tmm_normalized_dge <- edgeR::calcNormFactors(brca_hd_tep_filtered_dge, method = "TMM")
knitr::kable(brca_hd_tep_tmm_normalized_dge[["samples"]])
### Combine two data frames - gene metadata and sample counts
brca_hd_tep_tmm_normalized_mat <- edgeR::cpm(brca_hd_tep_tmm_normalized_dge, normalized.lib.size=TRUE)
meta_df <- data.frame(
NAME = rownames(brca_hd_tep_tmm_normalized_mat),
DESCRIPTION = rownames(brca_hd_tep_tmm_normalized_mat),
check.names = FALSE)
rownames(brca_hd_tep_tmm_normalized_mat) <- NULL
brca_hd_tep_tmm_normalized_expression_df <- data.frame(meta_df, brca_hd_tep_tmm_normalized_mat,  check.names = FALSE)
### Write out
expression_dataset_path <- file.path(output_dir, "brca_hd_tep_tmm_normalized_expression.txt")
write.table(brca_hd_tep_tmm_normalized_expression_df,
quote=FALSE,
sep = "\t",
file=expression_dataset_path,
row.names = FALSE)
brca_hd_tep_tmm_normalized_expression_file_df <- read.table(expression_dataset_path,
header = TRUE,
check.names = FALSE)
knitr::kable(head(brca_hd_tep_tmm_normalized_expression_file_df)[,c(1:4,8,9)])
### Calculate variability (dispersions) in data
brca_hd_tep_fitted_commondisp_dge <- edgeR::estimateCommonDisp(brca_hd_tep_tmm_normalized_dge)
brca_hd_tep_fitted_tagwise_dge <- edgeR::estimateTagwiseDisp(brca_hd_tep_fitted_commondisp_dge)
### Perform differential expression testing (comparison is 'BrCa' vs 'HD')
brca_hd_tep_de_tested_dge <- edgeR::exactTest(brca_hd_tep_fitted_tagwise_dge, pair = comparison)
### Perform multiple-testing correction using Benjamini-Hockberg procedure
brca_hd_tep_de_tested_tt <- edgeR::topTags(brca_hd_tep_de_tested_dge,
n = nrow(brca_hd_tep_tmm_normalized_dge),
adjust.method = "BH",
sort.by = "PValue")
knitr::kable(head(brca_hd_tep_de_tested_tt[["table"]]))
### Rank by inverse of p-value taking into account 'sign' of change in BrCa (i.e. increase/decrease) relative to HD
brca_hd_tep_rank_values <- sign(brca_hd_tep_de_tested_tt[["table"]][["logFC"]]) * (-1) * log10(brca_hd_tep_de_tested_tt[["table"]][["PValue"]])
### Take into account log10(0) = -Inf
brca_hd_tep_rank_values_max <- max(brca_hd_tep_rank_values[ brca_hd_tep_rank_values != Inf ])
brca_hd_tep_rank_values_unique <- sapply( brca_hd_tep_rank_values,
function(x) replace(x, is.infinite(x),
sign(x) * (brca_hd_tep_rank_values_max + runif(1))) )
### Construct the data frame we wish place into a tabular file
genenames <- (rownames(brca_hd_tep_de_tested_tt[["table"]]))
brca_hd_tep_ranks_df <- data.frame(gene=genenames,
rank=brca_hd_tep_rank_values_unique,
stringsAsFactors = FALSE)
brca_hd_tep_ordered_ranks_df <- brca_hd_tep_ranks_df[order(brca_hd_tep_ranks_df[,2], decreasing = TRUE), ]
## Write out to file
rank_list_path <- file.path(output_dir, "brca_hd_tep.rnk")
write.table(brca_hd_tep_ordered_ranks_df,
quote=FALSE,
sep = "\t",
file=rank_list_path,
row.names = FALSE)
brca_hd_tep_ordered_ranks_file_df <- read.table(rank_list_path,
header = TRUE,
check.names = FALSE)
ranks_head <- head(brca_hd_tep_ordered_ranks_file_df, n=5)
rownames(ranks_head) <- NULL
knitr::kable(ranks_head)
ranks_tail <- tail(brca_hd_tep_ordered_ranks_file_df, n=5)
rownames(ranks_tail) <- NULL
knitr::kable(ranks_tail)
n_samples <- dim(brca_hd_tep_filtered_dge)[2]
n_classes <- 2
l1 <- paste(n_samples, n_classes, "1")
l2 <- paste("#", brca_hd_tep_de_tested_tt[["comparison"]][1], brca_hd_tep_de_tested_tt[["comparison"]][2])
l3 <- paste(brca_hd_tep_filtered_dge[["samples"]][["group"]], collapse = " ")
brca_hd_tep_cls <- rbind(l1, l2, l3)
### Write out to file
categorical_class_path <- file.path(output_dir, "brca_hd_tep.cls")
write(brca_hd_tep_cls,
file=categorical_class_path,
sep = "\t")
rownames(brca_hd_tep_cls) <- NULL
brca_hd_tep_cls
getwd()
setwd()
em_fname <- "em_output.png"
em_output <- file.path(base_dir, em_fname)
url_png <- paste(base.url, "networks", current_network_suid, "views/first.png", sep="/")
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE)
### Declare general file directory paths
base_dir <- getwd()
data_dir <- file.path(base_dir, "data")
output_dir <- file.path(base_dir, "output")
dir.create(output_dir, showWarnings = FALSE)
### Declare paths to RNA-Seq (meta)data files
tep_rnaseq_metadata <- file.path(data_dir, "tep_rnaseq_metadata.txt")
tep_rnaseq_filelist <- c(file.path(data_dir, "MGH-BrCa-H-74_htsqct.txt"),
file.path(data_dir, "MGH-BrCa-H-68_htsqct.txt"),
file.path(data_dir, "MGH-BrCa-H-66_htsqct.txt"),
file.path(data_dir, "MGH-BrCa-H-59_htsqct.txt"),
file.path(data_dir, "MGH-BrCa-H-11_htsqct.txt"),
file.path(data_dir, "HD-5_htsqct.txt"),
file.path(data_dir, "HD-4_htsqct.txt"),
file.path(data_dir, "HD-3-1_htsqct.txt"),
file.path(data_dir, "HD-2-1_htsqct.txt"),
file.path(data_dir, "HD-1_htsqct.txt"))
tep_rnaseq_metadata_df <- read.table(tep_rnaseq_metadata,header = TRUE)
knitr::kable(tep_rnaseq_metadata_df)
index_HD_1_htsqct <- grepl("HD-1_htsqct.txt", tep_rnaseq_filelist)
rnaseq_HD_1_htsqct <- read.table(tep_rnaseq_filelist[index_HD_1_htsqct],
check.names=FALSE)
knitr::kable(head(rnaseq_HD_1_htsqct), col.names=c("",""))
library("SummarizedExperiment")
#' Merge a set of files representing RNA sequencing gene counts
#'
#' 1. Default parameter is do nothing (already matching gene set ids)
#' 2. Optional parameter is to map from input to target namespace
#' Data files must be in tab-delimited format with two columns and no header. The classes are defined by a meta data file which is a tab-delimited text file with headers for the sample read 'id' and 'class'. Each row entry is a corresponding filename and class assignment. Only accepts pair-wise comparison so there must be exactly 2 classes.
#'
#' @param metadata_file A metadata file
#' @param species A character array indicating the species with which to fetch gene models from bioMart, If NULL this mapping will not be performed
#' @param source_name attribute (gene namespace) input
#' @param target_name attribute (gene namespace) desired
#'
#' @return A \code{\link[SummarizedExperiment]{SummarizedExperiment}}
#'
#' @export
merge_data <- function(metadata_file, species, source_name, target_name, ...) {
if(!is.character(species)) stop('species must be of class character')
i <- 0
class_order <- c()
meta <- create_meta(metadata_file)
filelist <- list(...)
if(is.list(filelist)){
filelist <- unlist(filelist)
}
if(dim(meta)[1] != length(filelist)) stop('Mismatch in files declared in metadata')
for(file in filelist){
if(!file.exists(file)) stop('invalid file/directory')
fname <- basename(file)
findex <- which(meta$id == fname)
if(length(findex) == 0) stop(paste0('Could not find match in metadata for ', fname))
class_order <- append(class_order, which(meta$id == fname))
input_df <- read.table(file,
check.names = FALSE,
stringsAsFactors = FALSE,
row.names = 1,
sep = "\t",
header = FALSE)
colnames(input_df) <- tools::file_path_sans_ext(fname)
if (i == 0){
data_df <- input_df
i = i + 1
next()
}
data_df <- merge(data_df,
input_df,
by = "row.names",
all = FALSE)
rownames(data_df) <- data_df$Row.names
data_df <- subset(data_df, select = -Row.names)
i = i + 1
}
gene_model <- get_gene_model( data_df, species, source_name, target_name )
if(is.null(gene_model)) stop( 'Could not reliably map input gene ids' )
# Sync up data rows (name, order) with gene_model returned
data_df_mapped <- map_names(data_df, gene_model, source_name)
# Create the SummarizedExperiment
colData <- data.frame(class=meta[class_order,]$class, row.names=colnames(data_df_mapped))
data_se <- SummarizedExperiment::SummarizedExperiment(
assays = list(counts = data.matrix(data_df_mapped)),
rowRanges = gene_model,
colData=colData)
return(data_se)
}
#' Create a data frame housing the RNA-seq metadata
#'
#' This function requires a tab-delimited text file with headers for
#' the sample read 'id' and 'class'. Each row entry is a corresponding filename
#' and class assignment. Only accepts pair-wise comparison so there must be
#' exactly 2 classes.
#'
#' @param metadata_file a path to a tab-delimited metadata file
#' @return A data frame
#'
#' @export
create_meta <- function(metadata_file) {
if(!file.exists(metadata_file)) stop('file does not exist')
if(!grepl(".txt$", metadata_file)){
stop("Uploaded file must be a tab-delimited .txt file!")
}
meta <- read.table(metadata_file,
check.names = FALSE,
colClasses = c("character", "factor"),
sep = "\t", header=TRUE)
if(!all.equal(colnames(meta), c("id", "class"))) stop('check column headers')
return(meta)
}
#' Normalize the data.frame nameswith those on a \code{\link[GenomicRanges]{GRanges}} object
#'
#' !!!!!!!!!!!!Alert alert alert ---- mapping between namespaces is not bijective.!!!!!!!!!!!!!
#'
#' Assumes that the gene_model has a meta-data column with source_name
#'
#' @param data_df the data frame to synchronize
#' @param gene_model the \code{\link[GenomicRanges]{GRanges}} object to match rows with
#'
#' @return A \code{\link[base]{data.frame}} with the same rows and names as the input \code{\link[GenomicRanges]{GRanges}}
#'
#' @export
map_names <- function(data_df, gene_model, source_name){
# Filter data_df for source_name
indices_data_df_source <- rownames( data_df ) %in% GenomicRanges::mcols( gene_model )[[source_name]]
subset_data_df_source <- data_df[ indices_data_df_source, ]
# Recreate the data frame
merged_data_df <- merge( subset_data_df_source,
data.frame( GenomicRanges::mcols( gene_model ), target_name = names(gene_model) ),
by.x = "row.names", by.y = source_name)
# merged data could still have duplicates!
# indices_merged_data_df_unique <- !duplicated(merged_data_df[[ "Row.names" ]])
# merged_data_df_unique <- merged_data_df[indices_merged_data_df_unique,]
# Set row names to target_name
row.names( merged_data_df ) <- merged_data_df$target_name
# Drop name columns
merged_data_df <- merged_data_df[, -which(names(merged_data_df) %in% c("Row.names", "target_name")) ]
# Reorder the rows to match
merged_data_df_reordered <- merged_data_df[ match(names(gene_model), rownames(merged_data_df)), ]
return(merged_data_df_reordered)
}
#' Retrieve the gene info
#'
#'  !!!!!!!!!!!!Alert alert alert ---- mapping between namespaces is not bijective.!!!!!!!!!!!!!
#'
#' @param data_df the data frame of genes (rownames) and samples (colnames)
#' @param species the species (mouse, human)
#' @param source_name attribute (gene namespace) input
#' @param target_name attribute (gene namespace) desired
#'
#' @return A \code{\link[GenomicRanges]{GRanges}} having unique and valid target_name entries
#'
#' @export
get_gene_model <- function( data_df, species, source_name, target_name ){
if(missing(species) ||
!grepl("mouse", species, ignore.case = TRUE) &&
!grepl("human", species, ignore.case = TRUE)) stop("Species must be human or mouse")
dataset = switch(species,
mouse = "mmusculus_gene_ensembl",
human = "hsapiens_gene_ensembl")
mart_used = biomaRt::useMart("ENSEMBL_MART_ENSEMBL")
ensembl = biomaRt::useDataset(dataset, mart = mart_used)
attributes_available <- biomaRt::listAttributes(ensembl)
if( !source_name %in% attributes_available$name ||
!target_name %in% attributes_available$name ) stop("Invalid source/target name")
bm_info <- biomaRt::getBM(attributes = c("chromosome_name",
"start_position", "end_position", "strand",
source_name, target_name),
filters = source_name,
values = rownames(data_df),
mart = ensembl)
rowRanges <- GenomicRanges::GRanges(seqnames = paste0("chr", bm_info$chromosome_name),
ranges = IRanges::IRanges(start = bm_info$start_position, end = bm_info$end_position),
strand = bm_info$strand)
meta <- data.frame(bm_info[[source_name]])
colnames(meta) <- c(source_name)
GenomicRanges::mcols(rowRanges) <- meta
names(rowRanges) <- bm_info[[target_name]]
# Filter gene_model for valid target_name
# GRanges objects act like vectors for subsetting
gene_model <- rowRanges[ (names(rowRanges) != "") ]
gene_model <- gene_model[ !duplicated(GenomicRanges::mcols(gene_model)[[source_name]]) ]
gene_model <- gene_model[ !duplicated(names(gene_model)) ]
return(gene_model)
}
source_name <- "ensembl_gene_id"
target_name <- "hgnc_symbol"
species <- "human"
brca_hd_tep_se <- merge_data(
tep_rnaseq_metadata,
species,
source_name,
target_name,
tep_rnaseq_filelist)
setwd("~/Projects/PathwayCommons/web/guide_development/guide/src/collections/_workflows/rna_seq_to_enrichment_map_r_notebook")
data_df <- c("TP53")
species <- "human"
if(missing(species) ||
!grepl("mouse", species, ignore.case = TRUE) &&
!grepl("human", species, ignore.case = TRUE)) stop("Species must be human or mouse")
dataset = switch(species,
mouse = "mmusculus_gene_ensembl",
human = "hsapiens_gene_ensembl")
mart_used = biomaRt::useMart("ENSEMBL_MART_ENSEMBL")
ensembl = biomaRt::useDataset(dataset, mart = mart_used)
attributes_available <- biomaRt::listAttributes(ensembl)
View(attributes_available)
source <- "entrezgene"
source <- "hgnc_symbol"
target <- "entrezgene"
bm_info <- biomaRt::getBM(attributes = c("chromosome_name",
"start_position", "end_position", "strand",
source_name, target_name),
filters = source_name,
values = data_df,
mart = ensembl)
source_name <- "hgnc_symbol"
target_name <- "entrezgene"
bm_info <- biomaRt::getBM(attributes = c("chromosome_name",
"start_position", "end_position", "strand",
source_name, target_name),
filters = source_name,
values = data_df,
mart = ensembl)
View(bm_info)
source_name <- "uniprotswissprot"
data_df <- c("Q99988")
bm_info <- biomaRt::getBM(attributes = c("chromosome_name",
"start_position", "end_position", "strand",
source_name, target_name),
filters = source_name,
values = data_df,
mart = ensembl)
data_df <- c("A0A075B6K4 ")
data_df <- c("A0A075B6K4")
bm_info <- biomaRt::getBM(attributes = c("chromosome_name",
"start_position", "end_position", "strand",
source_name, target_name),
filters = source_name,
values = data_df,
mart = ensembl)
