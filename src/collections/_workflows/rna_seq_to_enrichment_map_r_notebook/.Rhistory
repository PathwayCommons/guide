#' exactly 2 classes.
#'
#' @param metadata_file a path to a tab-delimited metadata file
#' @return A data frame
#'
#' @export
create_meta <- function(metadata_file) {
if(!file.exists(metadata_file)) stop('file does not exist')
if(!grepl(".txt$", metadata_file)){
stop("Uploaded file must be a tab-delimited .txt file!")
}
meta <- read.table(metadata_file,
check.names = FALSE,
colClasses = c("character", "factor"),
sep = "\t", header=TRUE)
if(!all.equal(colnames(meta), c("id", "class"))) stop('check column headers')
return(meta)
}
#' Normalize the data.frame nameswith those on a \code{\link[GenomicRanges]{GRanges}} object
#'
#' !!!!!!!!!!!!Alert alert alert ---- mapping between namespaces is not bijective.!!!!!!!!!!!!!
#'
#' Assumes that the gene_model has a meta-data column with source_name
#'
#' @param data_df the data frame to synchronize
#' @param gene_model the \code{\link[GenomicRanges]{GRanges}} object to match rows with
#'
#' @return A \code{\link[base]{data.frame}} with the same rows and names as the input \code{\link[GenomicRanges]{GRanges}}
#'
#' @export
map_names <- function(data_df, gene_model, source_name){
# Filter data_df for source_name
indices_data_df_source <- rownames( data_df ) %in% GenomicRanges::mcols( gene_model )[[source_name]]
subset_data_df_source <- data_df[ indices_data_df_source, ]
# Recreate the data frame
merged_data_df <- merge( subset_data_df_source,
data.frame( GenomicRanges::mcols( gene_model ), target_name = names(gene_model) ),
by.x = "row.names", by.y = source_name)
# merged data could still have duplicates!
# indices_merged_data_df_unique <- !duplicated(merged_data_df[[ "Row.names" ]])
# merged_data_df_unique <- merged_data_df[indices_merged_data_df_unique,]
# Set row names to target_name
row.names( merged_data_df ) <- merged_data_df$target_name
# Drop name columns
merged_data_df <- merged_data_df[, -which(names(merged_data_df) %in% c("Row.names", "target_name")) ]
# Reorder the rows to match
merged_data_df_reordered <- merged_data_df[ match(names(gene_model), rownames(merged_data_df)), ]
return(merged_data_df_reordered)
}
#' Retrieve the gene info
#'
#'  !!!!!!!!!!!!Alert alert alert ---- mapping between namespaces is not bijective.!!!!!!!!!!!!!
#'
#' @param data_df the data frame of genes (rownames) and samples (colnames)
#' @param species the species (mouse, human)
#' @param source_name attribute (gene namespace) input
#' @param target_name attribute (gene namespace) desired
#'
#' @return A \code{\link[GenomicRanges]{GRanges}} having unique and valid target_name entries
#'
#' @export
get_gene_model <- function( data_df, species, source_name, target_name ){
if(missing(species) ||
!grepl("mouse", species, ignore.case = TRUE) &&
!grepl("human", species, ignore.case = TRUE)) stop("Species must be human or mouse")
dataset = switch(species,
mouse = "mmusculus_gene_ensembl",
human = "hsapiens_gene_ensembl")
mart_used = biomaRt::useMart("ENSEMBL_MART_ENSEMBL")
ensembl = biomaRt::useDataset(dataset, mart = mart_used)
attributes_available <- biomaRt::listAttributes(ensembl)
if( !source_name %in% attributes_available$name ||
!target_name %in% attributes_available$name ) stop("Invalid source/target name")
bm_info <- biomaRt::getBM(attributes = c("chromosome_name",
"start_position", "end_position", "strand",
source_name, target_name),
filters = source_name,
values = rownames(data_df),
mart = ensembl)
rowRanges <- GenomicRanges::GRanges(seqnames = paste0("chr", bm_info$chromosome_name),
ranges = IRanges::IRanges(start = bm_info$start_position, end = bm_info$end_position),
strand = bm_info$strand)
meta <- data.frame(bm_info[[source_name]])
colnames(meta) <- c(source_name)
GenomicRanges::mcols(rowRanges) <- meta
names(rowRanges) <- bm_info[[target_name]]
# Filter gene_model for valid target_name
# GRanges objects act like vectors for subsetting
gene_model <- rowRanges[ (names(rowRanges) != "") ]
gene_model <- gene_model[ !duplicated(GenomicRanges::mcols(gene_model)[[source_name]]) ]
gene_model <- gene_model[ !duplicated(names(gene_model)) ]
return(gene_model)
}
source_name <- "ensembl_gene_id"
target_name <- "hgnc_symbol"
species <- "human"
brca_hd_tep_se <- merge_data(
tep_rnaseq_metadata,
species,
source_name,
target_name,
tep_rnaseq_filelist)
brca_hd_tep_se
knitr::kable(SummarizedExperiment::colData(brca_hd_tep_se))
brca_hd_tep_rowRanged_df <- as.data.frame(SummarizedExperiment::rowRanges(brca_hd_tep_se))
knitr::kable(head(brca_hd_tep_rowRanged_df))
dim(brca_hd_tep_rowRanged_df)
knitr::kable(head(SummarizedExperiment::assays(brca_hd_tep_se)[["counts"]])[, c(1,2,6,7)])
### Minimum number of mapped read counts per sample
min_counts <- 5
### Declare baseline (i.e. control) and test classes
baseline_class <- "HD"
test_class <- "BrCa"
comparison <- c(baseline_class, test_class)
brca_hd_tep_se_counts <- SummarizedExperiment::assays(brca_hd_tep_se)[["counts"]]
brca_hd_tep_se_group <- SummarizedExperiment::colData(brca_hd_tep_se)[["class"]]
### Find genes (rows) with a minimum number of counts
index_test_class <- brca_hd_tep_se_group == comparison[1]
index_baseline_class <- brca_hd_tep_se_group == comparison[2]
row_with_mincount <-
rowSums(edgeR::cpm(brca_hd_tep_se_counts) > min_counts) >=
min(sum(index_baseline_class), sum(index_test_class))
### Subset the original data accordingly
brca_hd_tep_dge_counts <- brca_hd_tep_se_counts[row_with_mincount,]
### Push the data into the edgeR::DGEList
brca_hd_tep_filtered_dge <-
edgeR::DGEList(counts = brca_hd_tep_dge_counts, group = brca_hd_tep_se_group)
knitr::kable(head(brca_hd_tep_filtered_dge[["counts"]])[, c(1,2,5,6)])
knitr::kable(brca_hd_tep_filtered_dge[["samples"]])
brca_hd_tep_tmm_normalized_dge <- edgeR::calcNormFactors(brca_hd_tep_filtered_dge, method = "TMM")
knitr::kable(brca_hd_tep_tmm_normalized_dge[["samples"]])
### Combine two data frames - gene metadata and sample counts
brca_hd_tep_tmm_normalized_mat <- edgeR::cpm(brca_hd_tep_tmm_normalized_dge, normalized.lib.size=TRUE)
meta_df <- data.frame(
NAME = rownames(brca_hd_tep_tmm_normalized_mat),
DESCRIPTION = rownames(brca_hd_tep_tmm_normalized_mat),
check.names = FALSE)
rownames(brca_hd_tep_tmm_normalized_mat) <- NULL
brca_hd_tep_tmm_normalized_expression_df <- data.frame(meta_df, brca_hd_tep_tmm_normalized_mat,  check.names = FALSE)
### Write out
expression_dataset_path <- file.path(output_dir, "brca_hd_tep_tmm_normalized_expression.txt")
write.table(brca_hd_tep_tmm_normalized_expression_df,
quote=FALSE,
sep = "\t",
file=expression_dataset_path,
row.names = FALSE)
brca_hd_tep_tmm_normalized_expression_file_df <- read.table(expression_dataset_path,
header = TRUE,
check.names = FALSE)
knitr::kable(head(brca_hd_tep_tmm_normalized_expression_file_df)[,c(1:4,8,9)])
### Calculate variability (dispersions) in data
brca_hd_tep_fitted_commondisp_dge <- edgeR::estimateCommonDisp(brca_hd_tep_tmm_normalized_dge)
brca_hd_tep_fitted_tagwise_dge <- edgeR::estimateTagwiseDisp(brca_hd_tep_fitted_commondisp_dge)
### Perform differential expression testing (comparison is 'BrCa' vs 'HD')
brca_hd_tep_de_tested_dge <- edgeR::exactTest(brca_hd_tep_fitted_tagwise_dge, pair = comparison)
### Perform multiple-testing correction using Benjamini-Hockberg procedure
brca_hd_tep_de_tested_tt <- edgeR::topTags(brca_hd_tep_de_tested_dge,
n = nrow(brca_hd_tep_tmm_normalized_dge),
adjust.method = "BH",
sort.by = "PValue")
knitr::kable(head(brca_hd_tep_de_tested_tt[["table"]]))
### Rank by inverse of p-value taking into account 'sign' of change in BrCa (i.e. increase/decrease) relative to HD
brca_hd_tep_rank_values <- sign(brca_hd_tep_de_tested_tt[["table"]][["logFC"]]) * (-1) * log10(brca_hd_tep_de_tested_tt[["table"]][["PValue"]])
### Take into account log10(0) = -Inf
brca_hd_tep_rank_values_max <- max(brca_hd_tep_rank_values[ brca_hd_tep_rank_values != Inf ])
brca_hd_tep_rank_values_unique <- sapply( brca_hd_tep_rank_values,
function(x) replace(x, is.infinite(x),
sign(x) * (brca_hd_tep_rank_values_max + runif(1))) )
### Construct the data frame we wish place into a tabular file
genenames <- (rownames(brca_hd_tep_de_tested_tt[["table"]]))
brca_hd_tep_ranks_df <- data.frame(gene=genenames,
rank=brca_hd_tep_rank_values_unique,
stringsAsFactors = FALSE)
brca_hd_tep_ordered_ranks_df <- brca_hd_tep_ranks_df[order(brca_hd_tep_ranks_df[,2], decreasing = TRUE), ]
## Write out to file
rank_list_path <- file.path(output_dir, "brca_hd_tep.rnk")
write.table(brca_hd_tep_ordered_ranks_df,
quote=FALSE,
sep = "\t",
file=rank_list_path,
row.names = FALSE)
brca_hd_tep_ordered_ranks_file_df <- read.table(rank_list_path,
header = TRUE,
check.names = FALSE)
ranks_head <- head(brca_hd_tep_ordered_ranks_file_df, n=5)
rownames(ranks_head) <- NULL
knitr::kable(ranks_head)
ranks_tail <- tail(brca_hd_tep_ordered_ranks_file_df, n=5)
rownames(ranks_tail) <- NULL
knitr::kable(ranks_tail)
n_samples <- dim(brca_hd_tep_filtered_dge)[2]
n_classes <- 2
l1 <- paste(n_samples, n_classes, "1")
l2 <- paste("#", brca_hd_tep_de_tested_tt[["comparison"]][1], brca_hd_tep_de_tested_tt[["comparison"]][2])
l3 <- paste(brca_hd_tep_filtered_dge[["samples"]][["group"]], collapse = " ")
brca_hd_tep_cls <- rbind(l1, l2, l3)
### Write out to file
categorical_class_path <- file.path(output_dir, "brca_hd_tep.cls")
write(brca_hd_tep_cls,
file=categorical_class_path,
sep = "\t")
rownames(brca_hd_tep_cls) <- NULL
brca_hd_tep_cls
doEnrichment <- FALSE
### Declare user-defined settings
gsea_jar_path <- file.path("/Users/jeffreywong/bin/gsea-3.0.jar")
gsea_rpt_label <- "tep_BrCa_HD_analysis"
gsea_analysis_name <- "tep_BrCa_HD"
gsea_out <- file.path(getwd(), "gsea_output")
gsea_gmx <- file.path(getwd(),
"data",
"Human_GOBP_AllPathways_no_GO_iea_August_01_2017_symbol.gmt")
gsea_rank_list_path <- rank_list_path
gsea_num_permutations <- 1000
gsea_min_gs_size <- 15
gsea_max_gs_size <- 200
## Execute GSEA
command <- paste("java -cp", gsea_jar_path,
"-Xmx1G xtools.gsea.GseaPreranked",
"-rpt_label", gsea_analysis_name,
"-out", gsea_out,
"-gmx", gsea_gmx,
"-rnk", gsea_rank_list_path,
"-nperm", gsea_num_permutations,
"-set_min", gsea_min_gs_size,
"-set_max", gsea_max_gs_size,
"-collapse false",
"-scoring_scheme weighted",
"-permute gene_set",
"-num 100",
"-plot_top_x 20",
"-rnd_seed 12345",
"-zip_report false",
"-gui false",
">", paste("gsea_output_", gsea_rpt_label, ".txt", sep=""),
sep=" ")
if( isTRUE ( doEnrichment) ){
system(command)
}
gsea_tep_BrCa_HD_analysis_directory <- list.files(path = gsea_out, pattern = "\\.GseaPreranked")
devtools::install_github("cytoscape/cytoscape-automation/for-scripters/R/r2cytoscape")
# Basic connection settings
port.number = 1234
base.url = paste("http://localhost:", toString(port.number), "/v1", sep="")
doEnrichmentMap <- FALSE
### Construct path to GSEA results - 'edb' folder
### Ouptut from GSEA - update below to match your directory name
gsea_results <- file.path(gsea_out, gsea_tep_BrCa_HD_analysis_directory)
gsea_results_filename <- file.path(gsea_results, "edb", "results.edb")
### Define thresholds for GSEA enrichments
em_pvalue_gsea_threshold <- "0.01"
em_qvalue_gsea_threshold <- "0.01"
### Define thresholds for gene set similarity
em_similarity_threshold <- "0.375"
em_similarity_metric = "COMBINED"
#######################################
#create EM pvalue < 0.01 and qvalue < 0.01
#######################################
em_network_name <- paste(gsea_analysis_name, em_pvalue_gsea_threshold, em_qvalue_gsea_threshold, sep="_")
em_command = paste("enrichmentmap build analysisType=gsea",
"gmtFile=", gsea_gmx,
"pvalue=", em_pvalue_gsea_threshold,
"qvalue=", em_qvalue_gsea_threshold,
"similaritycutoff=", em_similarity_threshold,
"coefficients=", em_similarity_metric,
"ranksDataset1=", gsea_rank_list_path,
"enrichmentsDataset1=", gsea_results_filename,
"expressionDataset1=", expression_dataset_path,
sep=" ")
current_network_suid <- 0
if( isTRUE( doEnrichmentMap ) ){
current_network_suid <- r2cytoscape::commandRun(em_command)
response <- r2cytoscape::renameNetwork(em_network_name, network = current_network_suid)
}
em_fname <- "em_output.png"
em_output <- file.path(output_dir, em_fname)
url_png <- paste(base.url, "networks", current_network_suid, "views/first.png", sep="/")
### Pause for Cytoscape to render
if( isTRUE( doEnrichmentMap ) ){
response <- httr::GET(url=url_png)
writeBin(response$content, em_output)
}
### Auto-Annotate the Enrichment Map
aa_command = paste("autoannotate annotate-clusterBoosted clusterAlgorithm=MCL maxWords=3 network=", em_network_name, sep=" ")
### Enrichment Map command will return the suid of newly created network.
if( doEnrichmentMap == TRUE ){
response <- r2cytoscape::commandRun(aa_command)
}
em_aa_fname <- "em_output_aa.png"
em_output_aa <- file.path(output_dir, em_aa_fname)
url_png <- paste(base.url, "networks", current_network_suid, "views/first.png", sep="/")
### Pause for Cytoscape to render
if( isTRUE( doEnrichmentMap ) ){
Sys.sleep(30)
response <- httr::GET(url=url_png)
writeBin(response$content, em_output_aa)
}
doEnrichment <- TRUE
doEnrichment <- TRUE
### Declare user-defined settings
gsea_jar_path <- file.path("/Users/jeffreywong/bin/gsea-3.0.jar")
gsea_rpt_label <- "tep_BrCa_HD_analysis"
gsea_analysis_name <- "tep_BrCa_HD"
gsea_out <- file.path(getwd(), "gsea_output")
gsea_gmx <- file.path(getwd(),
"data",
"Human_GOBP_AllPathways_no_GO_iea_August_01_2017_symbol.gmt")
gsea_rank_list_path <- rank_list_path
gsea_num_permutations <- 1000
gsea_min_gs_size <- 15
gsea_max_gs_size <- 200
## Execute GSEA
command <- paste("java -cp", gsea_jar_path,
"-Xmx1G xtools.gsea.GseaPreranked",
"-rpt_label", gsea_analysis_name,
"-out", gsea_out,
"-gmx", gsea_gmx,
"-rnk", gsea_rank_list_path,
"-nperm", gsea_num_permutations,
"-set_min", gsea_min_gs_size,
"-set_max", gsea_max_gs_size,
"-collapse false",
"-scoring_scheme weighted",
"-permute gene_set",
"-num 100",
"-plot_top_x 20",
"-rnd_seed 12345",
"-zip_report false",
"-gui false",
">", paste("gsea_output_", gsea_rpt_label, ".txt", sep=""),
sep=" ")
if( isTRUE ( doEnrichment) ){
system(command)
}
devtools::install_github("cytoscape/cytoscape-automation/for-scripters/R/r2cytoscape")
# Basic connection settings
port.number = 1234
base.url = paste("http://localhost:", toString(port.number), "/v1", sep="")
### Construct path to GSEA results - 'edb' folder
### Ouptut from GSEA - update below to match your directory name
gsea_results <- file.path(gsea_out, gsea_tep_BrCa_HD_analysis_directory)
gsea_results_filename <- file.path(gsea_results, "edb", "results.edb")
### Define thresholds for GSEA enrichments
em_pvalue_gsea_threshold <- "0.01"
em_qvalue_gsea_threshold <- "0.01"
### Define thresholds for gene set similarity
em_similarity_threshold <- "0.375"
em_similarity_metric = "COMBINED"
#######################################
#create EM pvalue < 0.01 and qvalue < 0.01
#######################################
em_network_name <- paste(gsea_analysis_name, em_pvalue_gsea_threshold, em_qvalue_gsea_threshold, sep="_")
em_command = paste("enrichmentmap build analysisType=gsea",
"gmtFile=", gsea_gmx,
"pvalue=", em_pvalue_gsea_threshold,
"qvalue=", em_qvalue_gsea_threshold,
"similaritycutoff=", em_similarity_threshold,
"coefficients=", em_similarity_metric,
"ranksDataset1=", gsea_rank_list_path,
"enrichmentsDataset1=", gsea_results_filename,
"expressionDataset1=", expression_dataset_path,
sep=" ")
current_network_suid <- 0
if( isTRUE ( doEnrichment) ){
current_network_suid <- r2cytoscape::commandRun(em_command)
response <- r2cytoscape::renameNetwork(em_network_name, network = current_network_suid)
}
em_fname <- "em_output.png"
em_output <- file.path(output_dir, em_fname)
url_png <- paste(base.url, "networks", current_network_suid, "views/first.png", sep="/")
### Pause for Cytoscape to render
if( isTRUE ( doEnrichment) ){
response <- httr::GET(url=url_png)
writeBin(response$content, em_output)
}
em_fname <- "em_output.png"
em_output <- file.path(output_dir, em_fname)
url_png <- paste(base.url, "networks", current_network_suid, "views/first.png", sep="/")
### Pause for Cytoscape to render
if( isTRUE ( doEnrichment) ){
response <- httr::GET(url=url_png)
writeBin(response$content, em_output)
}
### Auto-Annotate the Enrichment Map
aa_command = paste("autoannotate annotate-clusterBoosted clusterAlgorithm=MCL maxWords=3 network=", em_network_name, sep=" ")
### Enrichment Map command will return the suid of newly created network.
if( isTRUE ( doEnrichment) ){
response <- r2cytoscape::commandRun(aa_command)
}
em_aa_fname <- "em_output_aa.png"
em_output_aa <- file.path(output_dir, em_aa_fname)
url_png <- paste(base.url, "networks", current_network_suid, "views/first.png", sep="/")
### Pause for Cytoscape to render
if( isTRUE ( doEnrichment) ){
Sys.sleep(30)
response <- httr::GET(url=url_png)
writeBin(response$content, em_output_aa)
}
doEnrichment <- TRUE
### Construct path to GSEA results - 'edb' folder
### Ouptut from GSEA - update below to match your directory name
gsea_results <- file.path(gsea_out, gsea_tep_BrCa_HD_analysis_directory)
gsea_results_filename <- file.path(gsea_results, "edb", "results.edb")
### Define thresholds for GSEA enrichments
em_pvalue_gsea_threshold <- "0.01"
em_qvalue_gsea_threshold <- "0.01"
### Define thresholds for gene set similarity
em_similarity_threshold <- "0.375"
em_similarity_metric = "COMBINED"
#######################################
#create EM pvalue < 0.01 and qvalue < 0.01
#######################################
em_network_name <- paste(gsea_analysis_name, em_pvalue_gsea_threshold, em_qvalue_gsea_threshold, sep="_")
em_command = paste("enrichmentmap build analysisType=gsea",
"gmtFile=", gsea_gmx,
"pvalue=", em_pvalue_gsea_threshold,
"qvalue=", em_qvalue_gsea_threshold,
"similaritycutoff=", em_similarity_threshold,
"coefficients=", em_similarity_metric,
"ranksDataset1=", gsea_rank_list_path,
"enrichmentsDataset1=", gsea_results_filename,
"expressionDataset1=", expression_dataset_path,
sep=" ")
current_network_suid <- 0
if( isTRUE ( doEnrichment) ){
current_network_suid <- r2cytoscape::commandRun(em_command)
response <- r2cytoscape::renameNetwork(em_network_name, network = current_network_suid)
}
em_fname <- "em_output.png"
em_output <- file.path(output_dir, em_fname)
url_png <- paste(base.url, "networks", current_network_suid, "views/first.png", sep="/")
### Pause for Cytoscape to render
if( isTRUE ( doEnrichment) ){
response <- httr::GET(url=url_png)
writeBin(response$content, em_output)
}
### Auto-Annotate the Enrichment Map
aa_command = paste("autoannotate annotate-clusterBoosted clusterAlgorithm=MCL maxWords=3 network=", em_network_name, sep=" ")
### Enrichment Map command will return the suid of newly created network.
if( isTRUE ( doEnrichment) ){
response <- r2cytoscape::commandRun(aa_command)
}
em_aa_fname <- "em_output_aa.png"
em_output_aa <- file.path(output_dir, em_aa_fname)
url_png <- paste(base.url, "networks", current_network_suid, "views/first.png", sep="/")
### Pause for Cytoscape to render
if( isTRUE ( doEnrichment) ){
Sys.sleep(30)
response <- httr::GET(url=url_png)
writeBin(response$content, em_output_aa)
}
gsea_tep_BrCa_HD_analysis_directory <- list.files(path = gsea_out, pattern = "\\.GseaPreranked")
em_fname <- "em_output.png"
em_output <- file.path(output_dir, em_fname)
url_png <- paste(base.url, "networks", current_network_suid, "views/first.png", sep="/")
### Pause for Cytoscape to render
if( isTRUE ( doEnrichment) ){
response <- httr::GET(url=url_png)
writeBin(response$content, em_output)
}
### Construct path to GSEA results - 'edb' folder
### Ouptut from GSEA - update below to match your directory name
gsea_results <- file.path(gsea_out, gsea_tep_BrCa_HD_analysis_directory)
gsea_results_filename <- file.path(gsea_results, "edb", "results.edb")
### Define thresholds for GSEA enrichments
em_pvalue_gsea_threshold <- "0.01"
em_qvalue_gsea_threshold <- "0.01"
### Define thresholds for gene set similarity
em_similarity_threshold <- "0.375"
em_similarity_metric = "COMBINED"
#######################################
#create EM pvalue < 0.01 and qvalue < 0.01
#######################################
em_network_name <- paste(gsea_analysis_name, em_pvalue_gsea_threshold, em_qvalue_gsea_threshold, sep="_")
em_command = paste("enrichmentmap build analysisType=gsea",
"gmtFile=", gsea_gmx,
"pvalue=", em_pvalue_gsea_threshold,
"qvalue=", em_qvalue_gsea_threshold,
"similaritycutoff=", em_similarity_threshold,
"coefficients=", em_similarity_metric,
"ranksDataset1=", gsea_rank_list_path,
"enrichmentsDataset1=", gsea_results_filename,
"expressionDataset1=", expression_dataset_path,
sep=" ")
current_network_suid <- 0
if( isTRUE ( doEnrichment) ){
current_network_suid <- r2cytoscape::commandRun(em_command)
response <- r2cytoscape::renameNetwork(em_network_name, network = current_network_suid)
}
em_fname <- "em_output.png"
em_output <- file.path(output_dir, em_fname)
url_png <- paste(base.url, "networks", current_network_suid, "views/first.png", sep="/")
### Pause for Cytoscape to render
if( isTRUE ( doEnrichment) ){
response <- httr::GET(url=url_png)
writeBin(response$content, em_output)
}
### Auto-Annotate the Enrichment Map
aa_command = paste("autoannotate annotate-clusterBoosted clusterAlgorithm=MCL maxWords=3 network=", em_network_name, sep=" ")
### Enrichment Map command will return the suid of newly created network.
if( isTRUE ( doEnrichment) ){
response <- r2cytoscape::commandRun(aa_command)
}
em_aa_fname <- "em_output_aa.png"
em_output_aa <- file.path(output_dir, em_aa_fname)
url_png <- paste(base.url, "networks", current_network_suid, "views/first.png", sep="/")
### Pause for Cytoscape to render
if( isTRUE ( doEnrichment) ){
Sys.sleep(30)
response <- httr::GET(url=url_png)
writeBin(response$content, em_output_aa)
}
